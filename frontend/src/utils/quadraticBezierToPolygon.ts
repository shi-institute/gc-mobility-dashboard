// this file generated by Claude 4 Sonnet

/**
 * Converts a quadratic Bézier curve to a polygon with specified thickness.
 *
 * This function samples points along a quadratic Bézier curve and creates offset
 * points on both sides to form a thick polygon that can be filled and stroked.
 * Handles degenerate cases where the tangent vector becomes zero.
 *
 * @param startX - X coordinate of the curve's start point
 * @param startY - Y coordinate of the curve's start point
 * @param controlX - X coordinate of the curve's control point
 * @param controlY - Y coordinate of the curve's control point
 * @param endX - X coordinate of the curve's end point
 * @param endY - Y coordinate of the curve's end point
 * @param thickness - Total thickness of the resulting polygon
 * @param segments - Number of segments to divide the curve into (higher = smoother)
 * @returns SVG polygon points string in format "x1,y1 x2,y2 ..."
 */
export function quadraticBezierToPolygon(
  startX: number,
  startY: number,
  controlX: number,
  controlY: number,
  endX: number,
  endY: number,
  thickness: number,
  segments: number = 20
): string {
  const points: [number, number][] = [];
  const halfThickness = thickness / 2;

  // Generate top edge points by sampling along the curve
  for (let i = 0; i <= segments; i++) {
    const t = i / segments; // Parameter from 0 to 1

    // Calculate point on quadratic Bézier curve using formula:
    // B(t) = (1-t)²P₀ + 2(1-t)tP₁ + t²P₂
    const x = (1 - t) * (1 - t) * startX + 2 * (1 - t) * t * controlX + t * t * endX;
    const y = (1 - t) * (1 - t) * startY + 2 * (1 - t) * t * controlY + t * t * endY;

    // Calculate tangent vector (first derivative of Bézier curve)
    // B'(t) = 2(1-t)(P₁-P₀) + 2t(P₂-P₁)
    let tx = 2 * (1 - t) * (controlX - startX) + 2 * t * (endX - controlX);
    let ty = 2 * (1 - t) * (controlY - startY) + 2 * t * (endY - controlY);

    // Normalize tangent vector and handle degenerate cases
    const tangentLength = Math.sqrt(tx * tx + ty * ty);
    if (tangentLength < 1e-10) {
      // Tangent is zero (inflection point), use overall curve direction
      tx = endX - startX;
      ty = endY - startY;
      const fallbackLength = Math.sqrt(tx * tx + ty * ty);
      if (fallbackLength > 0) {
        tx /= fallbackLength;
        ty /= fallbackLength;
      } else {
        // Curve is a single point, default to horizontal
        tx = 1;
        ty = 0;
      }
    } else {
      // Normalize tangent vector
      tx /= tangentLength;
      ty /= tangentLength;
    }

    // Calculate perpendicular normal vector (rotate tangent 90° counterclockwise)
    const nx = -ty * halfThickness;
    const ny = tx * halfThickness;

    // Add offset point for top edge
    points.push([x + nx, y + ny]);
  }

  // Generate bottom edge points in reverse order to close the polygon
  for (let i = segments; i >= 0; i--) {
    const t = i / segments;

    // Recalculate curve point (same as above)
    const x = (1 - t) * (1 - t) * startX + 2 * (1 - t) * t * controlX + t * t * endX;
    const y = (1 - t) * (1 - t) * startY + 2 * (1 - t) * t * controlY + t * t * endY;

    // Recalculate tangent vector
    let tx = 2 * (1 - t) * (controlX - startX) + 2 * t * (endX - controlX);
    let ty = 2 * (1 - t) * (controlY - startY) + 2 * t * (endY - controlY);

    // Handle degenerate cases (same logic as above)
    const tangentLength = Math.sqrt(tx * tx + ty * ty);
    if (tangentLength < 1e-10) {
      tx = endX - startX;
      ty = endY - startY;
      const fallbackLength = Math.sqrt(tx * tx + ty * ty);
      if (fallbackLength > 0) {
        tx /= fallbackLength;
        ty /= fallbackLength;
      } else {
        tx = 1;
        ty = 0;
      }
    } else {
      tx /= tangentLength;
      ty /= tangentLength;
    }

    // Calculate perpendicular normal vector
    const nx = -ty * halfThickness;
    const ny = tx * halfThickness;

    // Add offset point for bottom edge (opposite direction)
    points.push([x - nx, y - ny]);
  }

  // Convert points array to SVG polygon points string format
  return points.map((point) => point.join(',')).join(' ');
}
